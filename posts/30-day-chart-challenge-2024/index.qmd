---
title: "30 Day Chart Challenge 2024"
description: "Let's make some charts!"
author: "gregers kjerulf dubrow"
date: "today"
categories: [post, rstats, ggplot, dataviz, chartchallenge, tidytuesday, eurostat]
image: "prompts.png"
toc: true
lightbox: true
editor: 
  mode: source
---

```{r setup}
#| include: false
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "images/",
  out.width = "100%") 
```

![](prompts.png){width="75%" fig-align="left" fig-alt="image listing the prompts for the 30 day chart challenge 2024."}

## My Plan for the Challenge {#plan}

If you regularly scroll through dataviz social media you probably see lots of posts in April where people show off their work for the [30 Day Chart Challenge](https://github.com/30DayChartChallenge/Edition2024). I never participate in these chart or map challenges because usually they take me by surprise and it's alreayd a week in before I notice and then I figure I'm too late.

Well not this year. Even though I'm (checks calendar) *three weeks* late to the party, I'm going to try and add a few charts to the challenge. I figure it's a good way to keep me consistently creating new visualisations, using the prompts to spur me to think about different data sources and dataviz approaches. My plan is to:

-   Produce charts for as many prompts as possible, working in prompt-day order.
-   Post them to social media on my [Bluesky](https://bsky.app/profile/gregerskjerulf.bsky.social), [Mastodon](https://fosstodon.org/@Greg_Dubrow), [Twitter](https://twitter.com/greg_dubrow), and [LinkedIn](https://www.linkedin.com/in/dubrowg/) accounts.
-   Add them to this post, meaning the posting date will refresh to the date I've added the chart.So If I get to alot or even all of them, this will be a long post.
-   Use the table of contents to the right to navigate to a specific chart.

I may not get to every prompt, but I'll do what I can. So let's get going.

## Prompt #1 - Part-to-Whole {#prompt1}

I chose to interpret this prompt by doing a stacked bar chart displaying educational attainment as a proportion of populations by regions in the UK. It doubles as a late-to-the-party entry for the [January 23, 2024 Tidy Tuesday](https://github.com/rfordatascience/tidytuesday/tree/master/data/2024/2024-01-23) challenge.

The original data is from the UK Office of National Statistics, in a report they produced looking at [educational attainment by socio-economic factors](https://www.ons.gov.uk/peoplepopulationandcommunity/educationandchildcare/articles/whydochildrenandyoungpeopleinsmallertownsdobetteracademicallythanthoseinlargertowns/2023-07-25).

My plan for this was to knock out the chart in about an hour, but I needed up having to do a bit more data transformation than I thought. I also had to read up a bit on UK education [levels](https://www.gov.uk/what-different-qualification-levels-mean/list-of-qualification-levels) and [stages](https://www.gov.uk/national-curriculum). In the end, it took a few hours to get it as I wanted.

First we'll get and clean the data...

```{r prompt1_1, message=FALSE, ECHO = TRUE, eval= TRUE}
#| warning: false
#| message: false 
#| error: false
#| echo: true
#| eval: true
#| code-overflow: scroll
#| code-fold: true
#| code-summary: "Show code for getting and cleaning data"

library(tidyverse) # to do tidyverse things
library(tidytuesdayR) #to get data from tidy tuesday repo
library(tidylog) # to get a log of what's happening to the data
library(janitor) # tools for data cleaning
library(ggtext) # to help make ggplot text look good

# load tidy tuesday data
ukeduc1 <- tt_load("2024-01-23")

# create tibble from csv, clean data, add some fields for the chart
ukeduc <- as_tibble(ukeduc1$english_education) %>%
	mutate(town11nm = ifelse(town11nm == "Outer london BUAs", "Outer London BUAs", town11nm)) %>%
	mutate(ttwa_classification = ifelse(
		town11nm %in% c("Inner London BUAs", "Outer London BUAs"), 
		"Majority conurbation", ttwa_classification)) %>%
	mutate(ttwa11nm = ifelse(
		town11nm %in% c("Inner London BUAs", "Outer London BUAs"), "London", ttwa11nm)) %>%
	mutate(ttwa11cd = ifelse(
		town11nm %in% c("Inner London BUAs", "Outer London BUAs"), "E30000234", ttwa11cd)) %>%
	mutate(across(26:29, ~ifelse(is.na(.),0,.))) %>%
	mutate(level_sum = rowSums(.[c(26:29)])) %>%
	# to get the number of students in the achievement groups we need to multiply the cohort
	# by the percentage and divide by 100 as in the original data they were displayed as 
	# full numbers, eg 17.2 instead of 0.172.
	mutate(highest_level_qualification_achieved_by_age_22_na = 100 - level_sum) %>%
	mutate(n_lesslev1_age22 =
			round(highest_level_qualification_achieved_by_age_22_less_than_level_1 * (ks4_2012_2013_counts/100) ,0)) %>%
	mutate(n_lev1to2_age22 =
			round(highest_level_qualification_achieved_by_age_22_level_1_to_level_2 * (ks4_2012_2013_counts/100) ,0)) %>%
	mutate(n_lev3to5_age22 =
			round(highest_level_qualification_achieved_by_age_22_level_3_to_level_5 * (ks4_2012_2013_counts/100) ,0)) %>%
	mutate(n_lev6plus_age22 =
			round(highest_level_qualification_achieved_by_age_22_level_6_or_above * (ks4_2012_2013_counts/100) ,0)) %>%
	mutate(n_lev_na_age22 =
			round(highest_level_qualification_achieved_by_age_22_na * (ks4_2012_2013_counts/100) ,0))
```

Ok, so we have data, let's make the chart. It's a horizontal bar chart showing the eudcational attainment at age 22 of a cohort of 15-16 year old students who sat for college qualifying exams (GCSEs) in the 2012-13 school year. Meaning the ending time point here is 2018-19. Attainment is plotted by level and by region. Because the original data is by town, we have to group by region to get what we want.

```{r prompt1_2, message=FALSE, ECHO = TRUE, eval= TRUE}
#| fig.width: 7.5
#| fig.height: 4.0
#| fig-dpi: 300
#| warning: false
#| message: false 
#| error: false
#| echo: true
#| eval: true
#| code-overflow: scroll
#| code-fold: true
#| code-summary: "Show code for making the chart"

# need to create cohort population by region
ukeduc %>%
	rename(region =rgn11nm ) %>%
	# group by regions and create region totals 
	group_by(region) %>%
	summarise(region_cohort = sum(ks4_2012_2013_counts),
					region_levless1_age22 = sum(n_lesslev1_age22),
					region_lev1to2_age22 = sum(n_lev1to2_age22),
					region_lev3to5_age22 = sum(n_lev3to5_age22),
					region_lev6plus_age22 = sum(n_lev6plus_age22),
					region_lev_na_age22 = sum(n_lev_na_age22)) %>%
	# pivot longer and make the education attainment field into factors. 
	# factor labels for the chart
	pivot_longer(cols = ends_with("age22"), 
						names_to = "ed_ettain_age22", 
						values_to = "ed_attain_n") %>%
	mutate(
		ed_ettain_age22 = 
			factor(ed_ettain_age22, 
					levels = c("region_lev_na_age22", "region_levless1_age22", "region_lev1to2_age22", 
							"region_lev3to5_age22",  "region_lev6plus_age22"), 
					labels = c("No data", "Level <1", "Level = 1-2", "Level = 3-5", "Level = 6+"))) %>%
	mutate(ed_attain_pct = ed_attain_n / region_cohort) %>%
	mutate(ed_attain_pct2 = round(ed_attain_pct*100, 1)) %>%
	ungroup() %>%
	mutate(region = factor(region)) %>%
	filter(!is.na(region)) %>%
	# pass this temporary set thru to the ggplot call
	{. ->> tmp} %>%
	ggplot(aes(ed_attain_pct, fct_rev(region), fill = fct_rev(ed_ettain_age22))) +
	geom_bar(stat = "identity") +
	scale_x_continuous(
		expand = c(0,0), 
		breaks = c(0, 0.25, 0.50, 0.75, 1), 
		labels = c("0", "25%", "50%", "75%", "100%")) +
	geom_text(data = subset(tmp, ed_attain_pct >0.025),
		aes(label = scales::percent(round(ed_attain_pct , 2))),
					position = position_stack(vjust = 0.5),
					color= "white", vjust = 0.5, size = 5) +
	labs(title = "Students in London most likely to have at least 4-year degree by Age 22",
		subtitle = "Sixth Year Educational Outcomes for Level 4 2012-13 Cohort by UK Region",
		caption = "*Tidy Tuesday data 01/23/2024, from UK Office of National Statistics*",
		x = "", y = "Region") +
	scale_fill_brewer(palette = "Set2") +
	theme_minimal() +
	theme(legend.position = "bottom", legend.spacing.x = unit(0, 'cm'), 
			legend.key.width = unit(1.5, 'cm'), legend.margin=margin(-10, 0, 0, 0),
			plot.title = element_text(hjust = 1), 
			plot.caption = element_markdown(),
			panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
	guides(fill = guide_legend(
		label.position = "bottom", reverse = TRUE, 
		title = "Cohort at Age 22", title.position = "top"))
```

We see from this chart that most in regions the rate of 4-year college degree completion (level 6+) was in the mid-high 20s, with students from the London region having the highest rate at 36%.

```{r}
#| echo: false
#| eval: true
rm(tmp)
```

*created and posted April 21, 2024*

## Prompt #2 - Neo {#prompt2}

The way I chose to interpret "neo" was by using births by country, or new people by country. The data come from [EuroStat](https://ec.europa.eu/eurostat), via the [`eurostat`](https://github.com/rOpenGov/eurostat) package. I'll use total live births and births per 1000 people for the year 2022 (most recent year available). I'll use [`patchwork`](https://patchwork.data-imaginist.com/) to combine the plots. Unlike prompt 1, this only took a little more than an hour to do.

Getting the data is super simple, and it doesn't need much cleaning, so I'll do all the code in one chunk.

```{r prompt2, message=FALSE, ECHO = TRUE, eval= TRUE}
#| fig.width: 9.0
#| fig.height: 7.0
#| fig-dpi: 300
#| warning: false
#| message: false 
#| error: false
#| echo: true
#| eval: true
#| code-overflow: scroll
#| code-fold: true
#| code-summary: "Show code for getting data and making the plots"

# to know the table code "tps00204", I had to look up the dataset on-line and copy that value.
# there is a function in the package to list all available data.
births <- eurostat::get_eurostat("tps00204", type = "label", time_format = "num") %>%
	select(-freq) %>%
	rename(year = TIME_PERIOD)

# make the plots
total_births <-
births %>%
	filter(year == 2022) %>%
	filter(indic_de == "Live births - number") %>%
	filter(!grepl("Euro",geo)) %>%
	arrange(desc(values), geo) %>%
	mutate(geo = forcats::fct_inorder(geo)) %>%
	{. ->> tmp} %>%
	ggplot(aes(values, fct_rev(geo))) +
	geom_bar(stat = "identity", fill = "#FFCC00") +
	scale_y_discrete(position = "right") +
	# need to subset data to get highest label to align similar to the rest
	geom_text(data = subset(tmp, values <800000),
		aes(label = format(values, big.mark=",")),
						color= "#003399", size = 4,
						hjust = -.25, nudge_x = .25) +
	geom_text(data = subset(tmp, values >800000),
						aes(label = format(values, big.mark = ",")),
						color= "#003399", size = 4,
						hjust = 1, nudge_x = .5) +
	labs(y = "", x = "Total Live Births - 2022") +
	theme_minimal() +
	theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

births_per1k <-
births %>%
	filter(year == 2022) %>%
	filter(indic_de == "Crude birth rate - per thousand persons") %>%
	filter(!grepl("Euro",geo)) %>%
	arrange(desc(values), geo) %>%
	mutate(geo = forcats::fct_inorder(geo)) %>%
	ggplot(aes(values, fct_rev(geo))) +
	geom_bar(stat = "identity", fill = "#003399") +
	geom_text(aes(label = values),
						position = position_stack(vjust = 0.5),
						color= "#FFCC00", vjust = 0.5, size = 4) +
	labs(y = "", x = "Births per 1000 persons - 2022") +
	theme_minimal() +
	theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())


# put them together with patchwork
library(patchwork)
total_births + births_per1k + plot_annotation(
	title = 'Turkey tops in both total births and births / 1000 people',
	subtitle = 'France only other country top 10 in both measures. San Marino bottom in both',
	caption = 'Data from EuroStats using eurostat package')
```

There you have it. Turkey is tops in both total number of births and births per 1000 people. France is the only other country in the top 10. Interestingly, Spain is near the top in total number (it's a big country) but towards the bottom in births per 1000. San Marino is last in both total births and rate.

What other interesting insights do you see here?

```{r}
#| echo: false
#| eval: true
rm(tmp)
```

*created and posted April 22, 2024*

## Prompts #3 & 4 - Redo & Waffle {#prompts3and4}

For this prompt I fulfilled prompt 3 "redo" by redoing the chart for prompt 1, and made it a waffle chart to fulfill prompt 4. I'd never done a waffle chart before, so new chart type...hooray! Cheers to Yann Holtz for his [code-through](https://r-graph-gallery.com/web-waffle-for-time-evolution.html) on his "R Graph Gallery" website to help me better understand how to set-up the data and plot it.

I'm once again using educational attainment data from the UK, via a Tidy Tuesday set from January 2024. We'll get the data and make the chart in the same code chunk.

```{r prompt3&4, message=FALSE, ECHO = TRUE, eval= TRUE}
#| fig.width: 9.0
#| fig.height: 7.0
#| fig-dpi: 300
#| warning: false
#| message: false 
#| error: false
#| echo: true
#| eval: true
#| code-overflow: scroll
#| code-fold: true
#| code-summary: "Show code for getting data and making the plots"

library(tidyverse) # to do tidyverse things
library(tidylog) # to get a log of what's happening to the data
library(janitor) # tools for data cleaning
library(tidytuesdayR) #to get data from tidy tuesday repo

# some custom functions
source("~/Data/r/basic functions.R")

## ggplot helpers - load if necessary
library(waffle) # ggplot helper to make a waffle chart
library(ggtext) # helper functions for ggplot text

# load tidy tuesday data
ukeduc1 <- tt_load("2024-01-23")

# get variable names
ukeduc_names <- as_tibble(names(ukeduc1$english_education))

# create tibble from csv, clean data
ukeduc <- as_tibble(ukeduc1$english_education) %>%
	mutate(town11nm = ifelse(town11nm == "Outer london BUAs", "Outer London BUAs", town11nm)) %>%
	mutate(
		ttwa_classification = ifelse(town11nm %in% c("Inner London BUAs", "Outer London BUAs"),
																 "Majority conurbation", ttwa_classification)) %>%
	mutate(ttwa11nm = ifelse(town11nm %in% c("Inner London BUAs", "Outer London BUAs"),
													 "London", ttwa11nm)) %>%
	mutate(ttwa11cd = ifelse(town11nm %in% c("Inner London BUAs", "Outer London BUAs"),
													 "E30000234", ttwa11cd)) %>%
	mutate(across(26:29, ~ifelse(is.na(.),0,.))) %>%
	mutate(level_sum = rowSums(.[c(26:29)])) %>%
	mutate(highest_level_qualification_achieved_by_age_22_na = 100 - level_sum) %>%
	mutate(n_lesslev1_age22 =
				 	round(highest_level_qualification_achieved_by_age_22_less_than_level_1 * (ks4_2012_2013_counts/100) ,0)) %>%
	mutate(n_lev1to2_age22 =
				 	round(highest_level_qualification_achieved_by_age_22_level_1_to_level_2 * (ks4_2012_2013_counts/100) ,0)) %>%
	mutate(n_lev3to5_age22 =
				 	round(highest_level_qualification_achieved_by_age_22_level_3_to_level_5 * (ks4_2012_2013_counts/100) ,0)) %>%
	mutate(n_lev6plus_age22 =
				 	round(highest_level_qualification_achieved_by_age_22_level_6_or_above * (ks4_2012_2013_counts/100) ,0)) %>%
	mutate(n_lev_na_age22 =
				 	round(highest_level_qualification_achieved_by_age_22_na * (ks4_2012_2013_counts/100) ,0))

glimpse(ukeduc)

# cohort ed attainment by region
ukeduc2 <-
	ukeduc %>%
	rename(region =rgn11nm ) %>%
	group_by(region) %>%
	summarise(region_cohort = sum(ks4_2012_2013_counts),
						region_levless1_age22 = sum(n_lesslev1_age22),
						region_lev1to2_age22 = sum(n_lev1to2_age22),
						region_lev3to5_age22 = sum(n_lev3to5_age22),
						region_lev6plus_age22 = sum(n_lev6plus_age22)) %>%
	pivot_longer(cols = ends_with("age22"), names_to = "ed_attain_age22", values_to = "ed_attain_n") %>%
	mutate(ed_attain_pct = ed_attain_n / region_cohort) %>%
	mutate(ed_attain_pct2 = round(ed_attain_pct*100)) %>%
	mutate(region = factor(region))%>%
	filter(!is.na(region)) %>%
	select(region, region_cohort, ed_attain_age22, ed_attain_pct2) %>%
	## the data was a bit messy, so to get the values to sum to 100 to make the waffle
	## chart fill the plot area, I had to do a little reshaping after doing the percentages.
	pivot_wider(names_from = ed_attain_age22, values_from = ed_attain_pct2) %>%
	mutate(region_sum = rowSums(.[c(3:6)])) %>%
	mutate(region_lev_na_age22 = ifelse(region_sum < 100, 100 - region_sum, 0)) %>%
	select(-region_sum) %>%
	pivot_longer(cols = ends_with("age22"), names_to = "ed_attain_age22", values_to = "ed_attain_pct") %>%
	mutate(ed_attain_age22 =
			 	factor(ed_attain_age22,
			 				 levels = c("region_lev_na_age22", "region_levless1_age22", "region_lev1to2_age22",
			 				 					 "region_lev3to5_age22", "region_lev6plus_age22"),
			 				 labels = c("No data", "Level <1", "Level = 1-2",
			 				 					 "Level = 3-5", "Level = 6+")))
glimpse(ukeduc2)

## chart
ukeduc2	%>%
	ggplot(aes(fill = ed_attain_age22, values = ed_attain_pct)) +
	geom_waffle(na.rm=TRUE, n_rows=10, flip=TRUE, size = 0.33, colour = "white") +
	facet_wrap(~region, nrow=1,strip.position = "bottom") +
	scale_x_discrete() +
	scale_y_continuous(labels = function(x) x * 10, # make this multiplyer the same as n_rows
										 expand = c(0,0)) +
	scale_fill_brewer(palette = "Set2") +
		labs(title = "Students in London most likely to have at least 4-year degree by Age 22",
				 subtitle = "Sixth Year Educational Outcomes for Level 4 2012-13 Cohort by UK Region<br>
				 Each block = 1 %",
				 caption = "*Tidy Tuesday data 01/23/2024, from UK Office of National Statistics*",
				 x = "", y = "") +
	theme_minimal() +
		theme(legend.position = "bottom", legend.spacing.x = unit(0, 'cm'),
					legend.key.width = unit(1.5, 'cm'), legend.margin=margin(-10, 0, 0, 0),
					plot.title = element_text(hjust = 0), plot.subtitle = element_markdown(),
					plot.caption = element_markdown(),
					panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
	guides(fill = guide_legend(label.position = "bottom", 
											title = "Cohort at Age 22", 
											title.position = "top"))

```

So alright, a waffle chart. Similar insights from the horizontal bar, just visualized a bit differently.

*created and posted April 23, 2024*

## Prompt #5 - Diverging {#prompt5}

Staying with the theme of educational attainment, but switching countries to Denmark (where I was born and now live again), let's look at differences in educational attainment for people in Denmark aged 25-69. The data come from Danmarks Statistik (Statistics Danmark, the national statistics agency) via the [`danstat`](https://github.com/ValeriVoev/danstat) package. I've been wanting to use the package, this was a great excuse.

I won't do too much explaining about education levels in Denmark, you can read up on them on the [ministry's page](https://ufm.dk/en/education/the-danish-education-system).

The `danstat` package is fairly easy to use once you get the hang of sorting out the table name and number, and variable names and values you need to filter on. It's a good idea to start at Danmarks Statistik's [StatBank page](https://www.statbank.dk/statbank5a/default.asp?w=1680), search the data you want, and when you find the table, you'll see the code, in this case HFUDD11, and use that in the package calls. To see what I mean, let's start with getting the data.

```{r prompt5_1, message=FALSE, ECHO = TRUE, eval= TRUE}
#| warning: false
#| message: false 
#| error: false
#| echo: true
#| eval: true
#| code-overflow: scroll
#| code-fold: true
#| code-summary: "Show code for getting data"

library(tidyverse) # to do tidyverse things
library(tidylog) # to get a log of what's happening to the data
library(janitor) # tools for data cleaning
library(danstat) # package to get Danish statistics via api
library(ggtext) # enhancements for text in ggplot

# some custom functions
source("~/Data/r/basic functions.R")


# metadata for table variables, click thru nested tables to find variables and ids for filters
table_meta <- danstat::get_table_metadata(table_id = "hfudd11", variables_only = TRUE)

# create variable list using the ID value in the variable
variables_ed <- list(
	list(code = "bopomr", values = "000"),
	list(code = "hfudd", values = c("H10", "H20", "H30", "H35",
										"H40", "H50", "H60", "H70", "H80", "H90")),
	list(code = "køn", values = c("M","K")),
	list(code = "alder", values = c("25-29", "30-34", "35-39", "40-44", "45-49",
												"50-54", "55-59", "60-64", "65-69")),
	list(code = "tid", values = 2023))

# past variable list along with table name. 
# note that in package, table name is lower case, though upper case on statbank page.
edattain <- get_data("hfudd11", variables_ed, language = "da") %>%
	as_tibble() %>%
	select(sex = KØN, age = ALDER, edlevel = HFUDD, n = INDHOLD)

```

The data I pulled is by sex, age, and education level. I needed to age variable to filter for age 25+, as the set starts at age 15. At some point for another post I plan to look a bit more deeply at educational attainment here, including region and age and other fields. So let's clean the data and get it ready to plot a diverging bar chart.

Even though I've calculated percentages for sex by age by education level, I won't be doing any breakdowns by age here, again, that's a later independent post. But at least I have the code now.

```{r prompt5_2, message=FALSE, ECHO = TRUE, eval= TRUE}
#| warning: false
#| message: false 
#| error: false
#| echo: true
#| eval: true
#| code-overflow: scroll
#| code-fold: true
#| code-summary: "Show code for cleaning data"

edattain1 <- edattain %>%
	## create factors from the education levels
	mutate(edlevel =
		factor(edlevel,
			levels = c("H10 Grundskole", "H20 Gymnasiale uddannelser",
			"H30 Erhvervsfaglige uddannelser", "H35 Adgangsgivende uddannelsesforløb",
			"H40 Korte videregående uddannelser, KVU", "H50 Mellemlange videregående uddannelser, MVU",
			"H60 Bacheloruddannelser, BACH", "H70 Lange videregående uddannelser, LVU",
			"H80 Ph.d. og forskeruddannelser", "H90 Uoplyst mv."),
			labels = c("Grundskole/Primary", "Gymnasium",
			"Erhvervsfaglige/Vocational HS", "Adgangsgivende/Qualifying",
			"KVU/2-year college", "MVU/Professional BA",
			"Bachelor", "LVU/Masters", "PhD", "Not stated" ))) %>%
	mutate(sex = ifelse(sex == "Kvinder", "Kvinder/Women", "Mænd/Men")) %>%
	# calculate total number by sex
	arrange(sex, edlevel) %>%
	group_by(sex) %>%
	mutate(tot_sex = sum(n)) %>%
	ungroup() %>%
	# calculate total number by sex and ed level
	group_by(sex, edlevel) %>%
	mutate(tot_sex_edlev = sum(n)) %>%
	ungroup() %>%
	# calculate total number by sex and age
	group_by(sex, age) %>%
	mutate(tot_sex_age = sum(n)) %>%
	ungroup() %>%
	# calculate percentages 
	mutate(level_pct = round(tot_sex_edlev / tot_sex, 3)) %>%
	mutate(level_pct = ifelse(sex == "Mænd/Men", level_pct *-1, level_pct)) %>%
	mutate(level_pct2 = round(level_pct * 100, 1)) %>%
	mutate(age_level_pct = round(n / tot_sex_age, 3)) %>%
	mutate(age_level_pct = ifelse(sex == "Mænd/Men", age_level_pct *-1, age_level_pct)) %>%
	mutate(age_level_pct2 = round(age_level_pct * 100, 1))
```

Now let's make the plot.

```{r prompt5_3, message=FALSE, ECHO = TRUE, eval= TRUE}
#| fig.width: 9.0
#| fig.height: 7.0
#| fig-dpi: 300
#| warning: false
#| message: false 
#| error: false
#| echo: true
#| eval: true
#| code-overflow: scroll
#| code-fold: true
#| code-summary: "Show code for making the plot"

vlines_df <- data.frame(xintercept = seq(-100, 100, 20))

edattain1 %>%
	filter(!edlevel == "Not stated") %>%
	distinct(sex, edlevel, .keep_all = TRUE) %>%
	select(sex, edlevel:tot_sex, level_pct, level_pct2 ) %>%
	# pass this temporary set thru to the ggplot call
	{. ->> tmp} %>%
	ggplot() +
	geom_col(aes(x = -50, y = edlevel), width = 0.75, fill = "#e0e0e0") +
	geom_col(aes(x = 50, y = edlevel), width = 0.75, fill = "#e0e0e0") +
	geom_col(aes(x = level_pct2, y = edlevel, fill = sex, color = sex), width = 0.75) +
	scale_x_continuous(labels = function(x) abs(x), breaks = seq(-100, 100, 20)) +
	geom_vline(data = vlines_df, aes(xintercept = xintercept), color = "#FFFFFF", size = 0.1, alpha = 0.5) +
	coord_cartesian(clip = "off") +
	scale_fill_manual(values = c("#C8102E", "#FFFFFF")) +
	scale_color_manual(values = c("#C8102E", "#C8102E")) +
	geom_text(data = subset(tmp, sex == "Mænd/Men"),
				aes(x = level_pct2, y = edlevel, label = paste0(abs(level_pct2), "%")),
				size = 5, color = "#C8102E",
				hjust = 1, nudge_x = -.5) +
	geom_text(data = subset(tmp, sex == "Kvinder/Women"),
				aes(x = level_pct2, y = edlevel, label = paste0(abs(level_pct2), "%")),
				size = 5, color = "#C8102E",
				hjust = -.25) +
	labs(x = "", y = "",
			 title = "In Denmark, <span style = 'color: #C8102E;'>women</span> more likely than men for highest education
			 level to be <br>Professional BA (MVU) or Masters.<br><br>Men more likely to stop at primary level or vocational secondary diploma.",
			 subtitle = "<br>*Highest level of education attained by all people in Denmark aged 25-69 as of Sept 30 2023.
			 <br><span style = 'color: #C8102E;'>Women are red bars</span>, men are white.*",
			 caption = "*Data from Danmarks Statistik via danstat package*") +
	theme_minimal() +
	theme(panel.grid = element_blank(), plot.title = element_markdown(),
				plot.subtitle = element_markdown(), plot.caption = element_markdown(),
				legend.position = "none",
				axis.text.y = element_text(size = 10))

```

There it is, a simple, clean chart showing how highest educational attainment differs for women and men in Denmark. I'm definitely interested in exploring differences by age group and by region.

```{r}
#| echo: false
#| eval: true
rm(tmp)
```

*created and posted April 24, 2024*

## Prompt #6 - OECD {#prompt6}

Staying with the emerging theme of educational attainment, this prompt was a good excuse to try out the [`oecd` package](https://github.com/expersso/OECD). The package wraps functions to access OECD data through their API for their [Data Explorer platform](https://data-explorer.oecd.org/).

It's fairly straight forward to use...look up the table you want, set the filters, copy the API script and parse out as the package documentation shows. In the example they do not show it, but make sure if you set time parameters that you put it in the `start_date` and `end_date` calls. You can of course name the dataset and filters anything you want. I chose my names so they wouldn't conflict with function calls.

For this chart I looked at educational attainment in Nordic countries; Denmark, Finland, Iceland, Norway, & Sweden *(i)*, by sex for all people aged 25 to 64 in 2022. For the sake of expediency, I'll copy the overall format & theme from prompt 1.

*i) let's not get into here the difference between Nordic & Scandinavian, what constitutes Scandinavian & why...*

The code for getting the data and making the chart is below.

```{r prompt6}
#| fig.width: 9.0
#| fig.height: 6.0
#| fig-dpi: 300
#| warning: false
#| message: false 
#| error: false
#| echo: true
#| eval: true
#| code-overflow: scroll
#| code-fold: true
#| code-summary: "Show code for prompt 6"

## code for 30 Day Chart Challenge 2024, day 6 OECD
## educational attainment via OECD package
## nordics, by sex 25 to 64, 2020-2022

library(tidyverse) # to do tidyverse things
library(tidylog) # to get a log of what's happening to the data
library(janitor) # tools for data cleaning
library(OECD) # package to get OECD data via api
library(ggtext) # enhancements for text in ggplot

# table from website
# https://www.oecd-ilibrary.org/education/data/education-at-a-glance/educational-attainment-and-labour-force-status_889e8641-en

edattdata <- "OECD.CFE.EDS,DSD_REG_EDU@DF_ATTAIN,1.0"
edattfilter <- "A.CTRY.SWE+NOR+ISL+FIN+DNK...Y25T64.F+M.ISCED11_0T2+ISCED11_5T8+ISCED11_3_4.."

oecd1 <- get_dataset(edattdata, edattfilter, start_time = 2020, end_time = 2022)

# get metadata - helpful to create labels for factors.
# see package documentation on github 
# commented out here to speed up rendering of post html file...this takes a while to download
   # oecd_metadata <- get_data_structure(edattdata)

# gets labels for country codes...this step commented out, data loading from local file.
# datalabs_ct <- oecd_metadata$CL_REGIONAL %>%
# 	rename(COUNTRY = id)

datalabs_ct <- readRDS("~/Data/r/30 Day Chart Challenge/2024/data/oecd_datalabs_ct.rds") 

# keep only necessary vars, change some to factors & add labels
oecd <- oecd1 %>%
	mutate(EDUCATION_LEV =
		factor(EDUCATION_LEV,
			levels = c("ISCED11_0T2", "ISCED11_3_4", "ISCED11_5T8"),
			labels = c("Pre-primary thru lower secondary",
				 		"Upper secondary and non-degree tertiary", "Tertiary education"))) %>%
	mutate(SEX = case_when(SEX == "M" ~ "Male", SEX == "F" ~ "Female")) %>%
	mutate(pct_attain2 = as.numeric(ObsValue)) %>%
	mutate(pct_attain = pct_attain2 / 100) %>%
	# join to have labels instead of country abbrvs
	left_join(datalabs_ct) %>%
	select(country = label,  year = TIME_PERIOD, SEX, EDUCATION_LEV, pct_attain, pct_attain2) %>%
	clean_names()

## chart...horizontal stacked bar
oecd %>%
	filter(year == "2022") %>%
	ggplot(aes(pct_attain, fct_rev(country), fill = fct_rev(education_lev))) +
	geom_bar(stat = "identity") +
	scale_x_continuous(expand = c(0,0),
				breaks = c(.01, 0.25, 0.50, 0.75, .97),
				labels = c("0", "25%", "50%", "75%", "100%")) +
	facet_wrap(~ sex, nrow = 1) +
	geom_text(aes(label = scales::percent(round(pct_attain , 2))),
				position = position_stack(vjust = 0.5),
				color= "white", vjust = 0.5, size = 5) +
	labs(title = "In Nordic countries, women age 25-64 more likely than men to complete college.<br><br>
			 Finns have lowest levels of attainment stopping at lower secondary",
			 subtitle = "<br>*Educational Attainment in Nordic Countries, by Sex, ages 25-64 combined, 2022*",
			 caption = "*Data from OECD, via oecd package for r*",
			 x = "", y = "") +
	scale_fill_brewer(palette = "Set2") +
	theme_minimal() +
	theme(legend.position = "bottom", legend.spacing.x = unit(0, 'cm'),
				legend.key.width = unit(1.5, 'cm'), legend.margin=margin(-10, 0, 0, 0),
				plot.title = element_markdown(), plot.subtitle = element_markdown(),
				plot.caption = element_markdown(),
				axis.text.y = element_text(size = 12),
				panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
	guides(fill = guide_legend(label.position = "bottom", reverse = TRUE,
				title = "Education Levels", title.position = "top"))

```

You can see that there are some differences in levels of attainment between countries. I don't know enough context to speculate as to why. Also, as you add more countries to the filter, the education levels and age groups are aggregated into bigger buckets, presumably to facilitate comparisons. Denmark has a good national database where you can drill down more by age and level, so if I wanted to look at differences by smaller age groups and over time, I'd have to dig into the individual countries national statistics databanks and would have to hope that the age groups and attainment levels are similar enough.

*created and posted April 26, 2024*

## Prompt #7 - Hazards {#prompt7}

Hazards is vague enough to mean anything, and if you search the socials for maps submitted for this prompt you'll see a variety of approaches. Right away I thought of crime stats, and also right away I knew I wanted to make a map of crime data in Denmark.

So that's what I set out to do.

But very soon into building it I realized I wanted to visualise different types of crime, which meant multiple plots. So then I got it in my head that this should be an exercise in really getting comfortable with functional programming and iterating using `map()` or a similar approach.

So that's what I did.

Follow along now as we get data, build a plot function, map over it, and make some maps.

First, the data. As with the [diverging challenge](https://www.gregdubrow.io/posts/30-day-chart-challenge-2024/#prompt5) I got the data from [Danmarks Statistik](https://www.dst.dk/en) (Statistics Danmark, the national statistics agency). Unlike the diverging challenge, I did not end up using the [`danstat`](https://github.com/ValeriVoev/danstat) package.

Why? Well I wanted to use the [province aggregation](https://en.wikipedia.org/wiki/Provinces_of_Denmark), the middle level between towns and regions. I wanted to see a bit of nuance in the maps. The problem is, while province data can be pulled from the [StatBank data portal](https://www.statbank.dk/) the [API](https://www.dst.dk/en/Statistik/brug-statistikken/muligheder-i-statistikbanken/api#) only has cities, regions, and all of Denmark. So loading flat-files it is.

But In this first chunk we get the geographic boundary data. For this we'll be using NUTS3 level. What are the NUTS levels? (settle down, Beavis) Well, per the [European Commission and Eurostat](https://ec.europa.eu/eurostat/statistics-explained/index.php?title=Glossary:Nomenclature_of_territorial_units_for_statistics_(NUTS)) they are:

> "The Nomenclature of territorial units for statistics, abbreviated NUTS (from the French version Nomenclature des Unités territoriales statistiques) is a geographical nomenclature subdividing the economic territory of the European Union (EU) into regions at three different levels (NUTS 1, 2 and 3 respectively, moving from larger to smaller territorial units).

In Denmark NUTS1 is the entire country, NUTS2 are the major regions, and NUTS3 are the provinces. The process for doing this comes from one of the excellent tutorials by [Milos Popvic](https://github.com/milos-agathon/how-i-make-eurostat-maps/blob/main/R/main.r) in his *Milos Makes Maps* series of [video](https://www.youtube.com/@milos-makes-maps/videos) and code how-tos.

```{r prompt_7_1}
#| warning: false
#| message: false 
#| error: false
#| echo: true
#| eval: true
#| code-overflow: scroll
#| code-fold: true
#| code-summary: "Show code for getting map boundary data"

# load all the packages we'll need
library(tidyverse) # to do tidyverse things
library(sf) # to make our geo data mappable
library(giscoR) # gets the region level boundries
library(tidylog) # to get a log of what's happening to the data
library(janitor) # tools for data cleaning
library(danstat) # package to get Danish statistics via api
library(ggtext) # enhancements for text in ggplot
library(patchwork) # puts plots together

source("~/Data/r/basic functions.R")

### Get mapping data
# define longlat projection
crsLONGLAT <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

# get NUTS3 data for Denmark and use sf to make it plottable
nuts3_dk <- giscoR::gisco_get_nuts(
	year = "2021",	resolution = "3",
	nuts_level = "3", country = "DK") |>
	rename(province_name = NAME_LATN) |>
	sf::st_transform(crsLONGLAT)
```

Now we add the crime and population data via spreadsheet import, and join it to the map data. The crime data needs a bit of tidying up, shortening the names, some other text edits. We'll normalize crime data by incidents per 100,000 people. Because the crime data come by yearly quarters and I wanted one entire year (adding up the four quarters), I pulled population data for the start of the 3rd quarter of 2023. I figured that was a good representative time-point for the entire year.

```{r prompt_7_2}
#| warning: false
#| message: false 
#| error: false
#| echo: true
#| eval: true
#| code-overflow: scroll
#| code-fold: true
#| code-summary: "Show code for getting crime and population data"

crime_2023_1 <- readxl::read_excel("~/Data/r/30 Day Chart Challenge/2024/data/dk_crime_by_province_2023.xlsx") %>%
	clean_names() %>%
	fill(offence_cat_code) %>%
	fill(offence_cat_name) %>%
	rename_with(~ sub("^x", "tot_", .x), starts_with(("x"))) %>%
	mutate(tot_2023 = rowSums(.[c(5:8)])) %>%
	mutate(province_name = str_replace(province_name, "Province ", "")) %>%
	mutate(offence_cat_name = str_replace(offence_cat_name, ", total", "")) %>%
	mutate(offence_cat_name = str_replace(
		offence_cat_name, "Nature of the offence", "All offences")) %>%
	mutate(offence_cat_name = str_replace(
		offence_cat_name, "Offences against property", "Property crime")) %>%
	mutate(offence_cat_name = str_replace(
		offence_cat_name, "Crimes of violence", "Violent crime")) %>%
	mutate(offence_cat_name =
			factor(offence_cat_name,
			levels = c("All offences", "Criminal code", "Sexual offenses", "Violent crime", "Property crime",
				 		"Other offences", "Special acts"))) %>%
	select(province_name, offence_cat_name, tot_2023)

## get population data to normalize 
# based on total at start of 2023 Q3
pop_2023 <- readxl::read_excel("~/Data/r/30 Day Chart Challenge/2024/data/dk_pop_2023_q3.xlsx") %>%
	clean_names() %>%
	mutate(province_name = str_replace(province_name, "Province ", ""))

# join crime & population
crime_2023_2 <- crime_2023_1 %>%
	left_join(pop_2023) %>%
	mutate(crime_per1k = round(tot_2023 / tot_pop * 100000, 0))

## left_join nuts sf object to crime data to get sf object for plot
crime_2023 <- nuts3_dk %>%
	left_join(crime_2023_2, by = "province_name")
```

Now that we have a dataset ready to be mapped, it's time to build the plot function. Being fully honest, functional programming and iterating over objects have long been my `r` bugaboos. I have no idea why, but I just couldn't internalize the logic. But putting together the [bicycle rides post](https://www.gregdubrow.io/posts/my-year-of-riding-danishly/) where I employed [Cedric Scherer's tutorial](https://www.cedricscherer.com/2023/07/05/efficiency-and-consistency-automate-subset-graphics-with-ggplot2-and-purrr/) I started to get it.

It took much longer to trial-and-error a few different approaches and get the text and layout as I wanted than it would have to copy-paste-adjust the plot code seven times and stitch together with `patchwork`, but now I have a map function I can re-use. A small but helpful part of the function is the [`ggsflabel`](https://yutannihilation.github.io/ggsflabel/) package to help offset labels for Copenhagen (Byen København & Københavns omgen).

```{r prompt_7_3}
#| warning: false
#| message: false 
#| error: false
#| echo: true
#| eval: true
#| code-overflow: scroll
#| code-fold: true
#| code-summary: "Show code for the map function"

dk_crime_map <- function(offence, maptitle) {
	g <-
		ggplot() +
		geom_sf(data = (crime_2023 %>% filter(offence_cat_name== offence)),
						aes(fill = crime_per1k), color = "#FFFFFF", size = 3) +
		geom_sf_text(data = (crime_2023 %>%
					filter(province_name %notin% c("Byen København", "Københavns omegn")) %>%
					filter(offence_cat_name == "Special acts")),
						aes(label = province_name), nudge_x = -.5, size = 2)	+
		ggsflabel::geom_sf_label_repel(data = (crime_2023 %>%
					filter(province_name %in% c("Byen København", "Københavns omegn")) %>%
					filter(offence_cat_name == offence)),
						aes(label = province_name), size = 1.5,
						force = 1, nudge_x = 4, nudge_y = .75) +
		scale_fill_gradient(trans = "reverse") +
		labs(x = "", y = "") +
		theme_minimal() +
		ggtitle(maptitle) +
		theme(panel.grid = element_blank(),
				plot.title = element_text(size = 11, hjust = .6, vjust = -7),
				axis.line = element_blank(), axis.ticks = element_blank(),
				axis.text.x = element_blank(), axis.text.y = element_blank(),
				legend.position = c(.4, -.2), 
				legend.title = element_text(size = 7),
				legend.text = element_text(size = 7)
					) +
		guides(fill = guide_legend(
			title = "Incidents per 100K people",
			direction = "horizontal",
			keyheight = unit(1, units = "mm"),
			keywidth = unit(10, units = "mm"),
			title.position = "top",
			title.hjust = .5,
			label.hjust = .5,
			nrow = 1,
			byrow = T,
			reverse = F,
			label.position = "bottom"
		))

	return(g)
}
```

The function is ready, now we iterate over the seven crime categories and put the plots together in one image. To magnify it for better viewing, click on it to bring it up in a lightbox.

```{r prompt_7_4}
#| fig.width: 9.0
#| fig.height: 6.0
#| fig-dpi: 600
#| warning: false
#| message: false 
#| error: false
#| echo: true
#| eval: true
#| code-overflow: scroll
#| code-fold: true
#| code-summary: "Show code for generating the plots"

## map over all crime categories
# create list of crime types
crimecats <- unique(crime_2023_2$offence_cat_name)

# create plots, stitch together with patchwork
wrap_plots(
	map(crimecats, ~dk_crime_map(offence = .x, maptitle = .x)),
	widths = 5, heights = 5) +
	plot_annotation(
		title = "Crimes by Type and Province in Denmark, 2023",
		subtitle = "*Total Crimes per 100K people*",
		caption = "*Data from Danmarks Statistik. Criminal code = sexual offences + violence + property + other*",
		theme = theme(plot.subtitle = element_markdown(),
					plot.caption = element_markdown()))

```

If this were for an official company or organization report or academic publication there are some tweaks I'd want to make...the color palette, maybe writing a function to make the breaks better, spacing of province labels, maybe making it interactive with tool tips that show province name along with other data. I might do an inset or separate plots for Copenhagen. But for the purpose of the chart challenge I'm happy with it because it meets my goal, which was to build a plot function and iterate it over a vector, rather than copy-paste and edit the plot code.

*created and posted April 29, 2024*
